#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "mbedtls/md5.h"

#define MAX_MSG_LEN 256  // Maksymalna długość wiadomości w pliku
#define BLOCK_SIZE 8  

// Oryginalne wartości IV
unsigned char IV[16] = {
    0x01, 0x23, 0x45, 0x67,
    0x89, 0xab, 0xcd, 0xef,
    0xfe, 0xdc, 0xba, 0x98,
    0x76, 0x54, 0x32, 0x10
};
unsigned char M00[64];
unsigned char M0[64] = {
        0xd1, 0x31, 0xdd, 0x02, // 0x02dd31d1,
        0xc5, 0xe6, 0xee, 0xc4, // 0xc4eee6c5,
        0x69, 0x3d, 0x9a, 0x06, // 0x069a3d69,
        0x98, 0xaf, 0xf9, 0x5c, // 0x5cf9af98,
        0x2f, 0xca, 0xb5, 0x87, // 0x87b5ca2f,
        0x12, 0x46, 0x7e, 0xab, // 0xab7e4612,
        0x40, 0x04, 0x58, 0x3e, // 0x3e580440,
        0xb8, 0xfb, 0x7f, 0x89, // 0x897ffbb8,
        0x55, 0xad, 0x34, 0x06, // 0x0634ad55,
        0x09, 0xf4, 0xb3, 0x02, // 0x02b3f409,
        0x83, 0xe4, 0x88, 0x83, // 0x8388e483,
        0x25, 0x71, 0x41, 0x5a, // 0x5a417125,
        0x08, 0x51, 0x25, 0xe8, // 0xe8255108,
        0xf7, 0xcd, 0xc9, 0x9f, // 0x9fc9cdf7,
        0xd9, 0x1d, 0xbd, 0xf2, // 0xf2bd1dd9,
        0x80, 0x37, 0x3c, 0x5b, // 0x5b3c3780,
    };

    unsigned char M1[64] = {
        0x96, 0x0b, 0x1d, 0xd1, // 0xd11d0b96
        0xdc, 0x41, 0x7b, 0x9c, // 0x9c7b41dc
        0xe4, 0xd8, 0x97, 0xf4, // 0xf497d8e4
        0x5a, 0x65, 0x55, 0xd5, // 0xd555655a
        0x35, 0x73, 0x9a, 0xc7, // 0xc79a7335
        0xf0, 0xeb, 0xfd, 0x0c, // 0x0cfdebf0
        0x30, 0x29, 0xf1, 0x66, // 0x66f12930
        0xd1, 0x09, 0xb1, 0x8f, // 0x8fb109d1
        0x75, 0x27, 0x7f, 0x79, // 0x797f2775
        0x30, 0xd5, 0x5c, 0xeb, // 0xeb5cd530
        0x22, 0xe8, 0xad, 0xba, // 0xbaade822
        0x79, 0xcc, 0x15, 0x5c, // 0x5c15cc79
        0xed, 0x74, 0xcb, 0xdd, // 0xddcb74ed
        0x5f, 0xc5, 0xd3, 0x6d, // 0x6dd3c55f
        0xb1, 0x9b, 0x0a, 0xd8, // 0xd80a9bb1
        0x35, 0xcc, 0xa7, 0xe3, // 0xe3a7cc35
    };

    unsigned char M0_prime[64] = {
        0xd1, 0x31, 0xdd, 0x02, // 0x02dd31d1,
        0xc5, 0xe6, 0xee, 0xc4, // 0xc4eee6c5,
        0x69, 0x3d, 0x9a, 0x06, // 0x069a3d69,
        0x98, 0xaf, 0xf9, 0x5c, // 0x5cf9af98,
        0x2f, 0xca, 0xb5, 0x07, // 0x07b5ca2f,
        0x12, 0x46, 0x7e, 0xab, // 0xab7e4612,
        0x40, 0x04, 0x58, 0x3e, // 0x3e580440,
        0xb8, 0xfb, 0x7f, 0x89, // 0x897ffbb8,
        0x55, 0xad, 0x34, 0x06, // 0x0634ad55,
        0x09, 0xf4, 0xb3, 0x02, // 0x02b3f409,
        0x83, 0xe4, 0x88, 0x83, // 0x8388e483,
        0x25, 0xf1, 0x41, 0x5a, // 0x5a41f125,
        0x08, 0x51, 0x25, 0xe8, // 0xe8255108,
        0xf7, 0xcd, 0xc9, 0x9f, // 0x9fc9cdf7,
        0xd9, 0x1d, 0xbd, 0x72, // 0x72bd1dd9,
        0x80, 0x37, 0x3c, 0x5b, // 0x5b3c3780,
    };

    unsigned char M1_prime[64] = {
        0x96, 0x0b, 0x1d, 0xd1, // 0xd11d0b96
        0xdc, 0x41, 0x7b, 0x9c, // 0x9c7b41dc
        0xe4, 0xd8, 0x97, 0xf4, // 0xf497d8e4
        0x5a, 0x65, 0x55, 0xd5, // 0xd555655a
        0x35, 0x73, 0x9a, 0x47, // 0x479a7335
        0xf0, 0xeb, 0xfd, 0x0c, // 0x0cfdebf0
        0x30, 0x29, 0xf1, 0x66, // 0x66f12930
        0xd1, 0x09, 0xb1, 0x8f, // 0x8fb109d1
        0x75, 0x27, 0x7f, 0x79, // 0x797f2775
        0x30, 0xd5, 0x5c, 0xeb, // 0xeb5cd530
        0x22, 0xe8, 0xad, 0xba, // 0xbaade822
        0x79, 0x4c, 0x15, 0x5c, // 0x5c154c79
        0xed, 0x74, 0xcb, 0xdd, // 0xddcb74ed
        0x5f, 0xc5, 0xd3, 0x6d, // 0x6dd3c55f
        0xb1, 0x9b, 0x0a, 0x58, // 0x580a9bb1
        0x35, 0xcc, 0xa7, 0xe3, // 0xe3a7cc35
    };
    // unsigned char M0[64] = {
    //     0x02, 0xdd, 0x31, 0xd1, // 0x02dd31d1,
    //     0xc4, 0xee, 0xe6, 0xc5, // 0xc4eee6c5,
    //     0x06, 0x9a, 0x3d, 0x69, // 0x069a3d69,
    //     0x5c, 0xf9, 0xaf, 0x98, // 0x5cf9af98,
    //     0x87, 0xb5, 0xca, 0x2f, // 0x87b5ca2f,
    //     0xab, 0x7e, 0x46, 0x12, // 0xab7e4612,
    //     0x3e, 0x58, 0x04, 0x40, // 0x3e580440,
    //     0x89, 0x7f, 0xfb, 0xb8, // 0x897ffbb8,
    //     0x06, 0x34, 0xad, 0x55, // 0x0634ad55,
    //     0x02, 0xb3, 0xf4, 0x09, // 0x02b3f409,
    //     0x83, 0x88, 0xe4, 0x83, // 0x8388e483,
    //     0x5a, 0x41, 0x71, 0x25, // 0x5a417125,
    //     0xe8, 0x25, 0x51, 0x08, // 0xe8255108,
    //     0x9f, 0xc9, 0xcd, 0xf7, // 0x9fc9cdf7,
    //     0xf2, 0xbd, 0x1d, 0xd9, // 0xf2bd1dd9,
    //     0x5b, 0x3c, 0x37, 0x80, // 0x5b3c3780,
    // };

    // unsigned char M1[64] = {
    //     0xd1, 0x1d, 0x0b,  0x96,// 0xd11d0b96
    //     0x9c, 0x7b, 0x41,  0xdc,// 0x9c7b41dc
    //     0xf4, 0x97, 0xd8,  0xe4,// 0xf497d8e4
    //     0xd5, 0x55, 0x65,  0x5a,// 0xd555655a
    //     0xc7, 0x9a, 0x73,  0x35,// 0xc79a7335
    //     0x0c, 0xfd, 0xeb,  0xf0,// 0x0cfdebf0
    //     0x66, 0xf1, 0x29,  0x30,// 0x66f12930
    //     0x8f, 0xb1, 0x09,  0xd1,// 0x8fb109d1
    //     0x79, 0x7f, 0x27,  0x75,// 0x797f2775
    //     0xeb, 0x5c, 0xd5,  0x30,// 0xeb5cd530
    //     0xba, 0xad, 0xe8,  0x22,// 0xbaade822
    //     0x5c, 0x15, 0xcc,  0x79,// 0x5c15cc79
    //     0xdd, 0xcb, 0x74,  0xed,// 0xddcb74ed
    //     0x6d, 0xd3, 0xc5,  0x5f,// 0x6dd3c55f
    //     0xd8, 0x0a, 0x9b,  0xb1,// 0xd80a9bb1
    //     0xe3, 0xa7, 0xcc,  0x35,// 0xe3a7cc35
    // };

    // unsigned char M0_prime[64] = {
    //     0x02, 0xdd, 0x31, 0xd1,  // 0x02dd31d1,
    //     0xc4, 0xee, 0xe6, 0xc5,  // 0xc4eee6c5,
    //     0x06, 0x9a, 0x3d, 0x69,  // 0x069a3d69,
    //     0x5c, 0xf9, 0xaf, 0x98,  // 0x5cf9af98,
    //     0x07, 0xb5, 0xca, 0x2f,  // 0x07b5ca2f,
    //     0xab, 0x7e, 0x46, 0x12,  // 0xab7e4612,
    //     0x3e, 0x58, 0x04, 0x40,  // 0x3e580440,
    //     0x89, 0x7f, 0xfb, 0xb8,  // 0x897ffbb8,
    //     0x06, 0x34, 0xad, 0x55,  // 0x0634ad55,
    //     0x02, 0xb3, 0xf4, 0x09,  // 0x02b3f409,
    //     0x83, 0x88, 0xe4, 0x83,  // 0x8388e483,
    //     0x5a, 0x41, 0xf1, 0x25,  // 0x5a41f125,
    //     0xe8, 0x25, 0x51, 0x08,  // 0xe8255108,
    //     0x9f, 0xc9, 0xcd, 0xf7,  // 0x9fc9cdf7,
    //     0x72, 0xbd, 0x1d, 0xd9,  // 0x72bd1dd9,
    //     0x5b, 0x3c, 0x37, 0x80,  // 0x5b3c3780,
    // };

    // unsigned char M1_prime[64] = {
    //     0xd1, 0x1d, 0x0b, 0x96,   // 0xd11d0b96
    //     0x9c, 0x7b, 0x41, 0xdc,   // 0x9c7b41dc
    //     0xf4, 0x97, 0xd8, 0xe4,   // 0xf497d8e4
    //     0xd5, 0x55, 0x65, 0x5a,   // 0xd555655a
    //     0x47, 0x9a, 0x73, 0x35,   // 0x479a7335
    //     0x0c, 0xfd, 0xeb, 0xf0,   // 0x0cfdebf0
    //     0x66, 0xf1, 0x29, 0x30,   // 0x66f12930
    //     0x8f, 0xb1, 0x09, 0xd1,   // 0x8fb109d1
    //     0x79, 0x7f, 0x27, 0x75,   // 0x797f2775
    //     0xeb, 0x5c, 0xd5, 0x30,   // 0xeb5cd530
    //     0xba, 0xad, 0xe8, 0x22,   // 0xbaade822
    //     0x5c, 0x15, 0x4c, 0x79,   // 0x5c154c79
    //     0xdd, 0xcb, 0x74, 0xed,   // 0xddcb74ed
    //     0x6d, 0xd3, 0xc5, 0x5f,   // 0x6dd3c55f
    //     0x58, 0x0a, 0x9b, 0xb1,   // 0x580a9bb1
    //     0xe3, 0xa7, 0xcc, 0x35,   // 0xe3a7cc35
    // };


void parse_file(const char* filename) {
    FILE *file = fopen(filename, "r");
    if (!file) {
        printf("Unable to open file: %s\n", filename);
        return;
    }

    unsigned char M0[64] = {0}, M1[64] = {0};  // Dwie tablice na wiadomości
    char buffer[100];  // Bufor na linie
    int message_number = 0;
    int index = 0;

    while (fgets(buffer, sizeof(buffer), file)) {
        index = 0;  // Reset indeksu dla każdej wiadomości
        char *token = strtok(buffer, " \n");  // Tokenizacja według spacji i nowej linii

        while (token != NULL) {
            int length = strlen(token);

            // Jeżeli długość bloku to 7, dodaj 0 na początku
            if (length == 7) {
                char temp[9];
                snprintf(temp, sizeof(temp), "0%s", token);
                strcpy(token, temp);  // Nadpisz token poprawionym ciągiem
                length = 8;  // Aktualizuj długość
            }

            // Przetwarzaj każdy blok na dwuznakowe segmenty szesnastkowe
            for (int i = 0; i < length; i += 2) {
                char hex_str[2] = { token[i], token[i + 1] };

                unsigned char value = (unsigned char) strtol(hex_str, NULL, 16);

                if (message_number == 0) {
                    M0[index++] = value;
                } else if (message_number == 1) {
                    M1[index++] = value;
                }

                // Sprawdź, czy przekroczyliśmy rozmiar tablicy
                if (index >= 64) {
                    break;
                }
            }

            token = strtok(NULL, " \n");
        }

        message_number++;  // Przejście do kolejnej wiadomości
        if (message_number > 1) {
            break;  // Przerwij po przetworzeniu dwóch wiadomości
        }
    }

    fclose(file);

    // Wyświetlanie zawartości tablicy M0
    printf("unsigned char M0[64] = {\n    ");
    for (int i = 0; i < 64; i++) {
        printf("0x%02x", M0[i]);
        if (i < 63) {
            printf(", ");
        }
        if ((i + 1) % 8 == 0 && i < 63) {
            printf("\n    ");
        }
    }
    printf("\n};\n");

    // Wyświetlanie zawartości tablicy M1
    printf("unsigned char M1[64] = {\n    ");
    for (int i = 0; i < 64; i++) {
        printf("0x%02x", M1[i]);
        if (i < 63) {
            printf(", ");
        }
        if ((i + 1) % 8 == 0 && i < 63) {
            printf("\n    ");
        }
    }
    printf("\n};\n");
}

void print_hash(unsigned char hash[16]) {
    for (int i = 0; i < 16; i++) {
        printf("%02x", hash[i]);
    }
    printf("\n");
}

void print_m(unsigned char hash[64]) {
    for (int i = 0; i < 64; i++) {
        printf("%02x", hash[i]);
    }
    printf("\n");
}

// Funkcja do obliczania MD5
void calculate_md5(unsigned char *input, size_t input_len, unsigned char *output) {
    mbedtls_md5_context ctx;
    mbedtls_md5_init(&ctx);
    mbedtls_md5_starts(&ctx);
    mbedtls_md5_update(&ctx, input, input_len);
    mbedtls_md5_finish(&ctx, output);
}

// Funkcja do obliczania podwójnego MD5
void double_md5(unsigned char *iv, unsigned char *M0, size_t M0_len, unsigned char *M1, size_t M1_len, unsigned char *output) {
    unsigned char temp_hash[16];

    // Oblicz MD5 dla IV + M0
    unsigned char *combined_M0 = malloc(M0_len + M0_len); // 16 (IV) + M0_len
    memcpy(combined_M0, M0, M0_len);
    memcpy(combined_M0 + M0_len, M1, M1_len);
    
    // calculate_md5(combined_M0, 16 + M0_len, temp_hash);
    // free(combined_M0); // Zwolnienie pamięci

    // // Oblicz MD5 dla (MD5(IV, M0) + M1)
    // unsigned char *combined_final = malloc(16 + M1_len); // 16 (temp_hash) + M1_len
    // memcpy(combined_final, temp_hash, 16);
    // memcpy(combined_final + 16, M1, M1_len);

    calculate_md5(combined_M0, M0_len + M1_len, output);
    free(combined_M0); // Zwolnienie pamięci
}

int main(int argc, char *argv[]) {

    if (argc < 2) {
        printf("Użycie: %s <nazwa_pliku>\n", argv[0]);
        return 1;
    }

    parse_file(argv[1]);

    unsigned char hash1[16], hash2[16];

    // Obliczanie MD5 dla (IV + M0) + M1
    double_md5(IV, M0, sizeof(M0), M1, sizeof(M1), hash1);
    
    // Obliczanie MD5 dla (IV + M0') + M1'
    double_md5(IV, M0_prime, sizeof(M0_prime), M1_prime, sizeof(M1_prime), hash2);

    // Wyświetl wyniki
    printf("Hash 1: ");
    print_hash(hash1);
    printf("Hash 2: ");
    print_hash(hash2);

    // Porównanie hashy
    if (memcmp(hash1, hash2, 16) == 0) {
        printf("Kolizja znaleziona!\n");
    } else {
        printf("Brak kolizji.\n");
    }

    print_m(M00);
    printf("\n");
    print_m(M1);

    return 0;
}